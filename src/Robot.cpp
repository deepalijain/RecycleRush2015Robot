// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Robot.h"
#include <iostream>
#include "Commands/DriveCommand.h"
#include "Commands/DriveElevator.h"
#include "Commands/PositionElevator.h"
#include "Commands/DrivePID.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
DriveSubsystem *Robot::driveSubsystem = 0;
Elevator *Robot::elevator = 0;
ArmFlaps *Robot::armFlaps = 0;
TotePusher *Robot::totePusher = 0;
OI *Robot::oi = 0;
Command *Robot::driveCommand = 0;
Command *Robot::driveElevatorCommand = 0;
Command *Robot::holdElevatorCommand = 0;

int Ticks = 0;

static double driveP = 0;
static double driveI = 0;
static double driveD = 0;
static double driveF = 0;
static double drivePIDDistance = 0;

static double elevatorP = 0;
static double elevatorI = 0;
static double elevatorD = 0;
static double elevatorF = 0;
static double elevatorPIDDistance = 0;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	driveSubsystem = new DriveSubsystem();
	elevator = new Elevator();
	armFlaps = new ArmFlaps;
	totePusher = new TotePusher;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi = new OI();
	driveCommand = new DriveCommand();
	// PositionElevator(0) means maintain current position, which is why we
	// use the word "hold" here. Other instances of positionElevator have
	// parameters of 1 or -1
	holdElevatorCommand = new PositionElevator(0);
	driveElevatorCommand = new DriveElevator();



	lw = LiveWindow::GetInstance();

	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

  }

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){

}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();
	UpdateDashboardPeriodic();
}

void Robot::AutonomousInit() {
	SmartDashboard::PutNumber("driveP", driveP);
	SmartDashboard::PutNumber("driveI", driveI);
	SmartDashboard::PutNumber("driveD", driveD);
	SmartDashboard::PutNumber("driveF", driveF);
	SmartDashboard::PutNumber("drivePIDDistance", drivePIDDistance);

	SmartDashboard::PutNumber("elevatorP", elevatorP);
	SmartDashboard::PutNumber("elevatorI", elevatorI);
	SmartDashboard::PutNumber("elevatorD", elevatorD);
	SmartDashboard::PutNumber("elevatorF", elevatorF);
	SmartDashboard::PutNumber("elevatorPIDDistance", elevatorPIDDistance);

	RobotMap::driveBackLeft->SetPosition(0.0);

	if (autonomousCommand != NULL)
		autonomousCommand->Start();

}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
	UpdateDashboardPeriodic();
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to 
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand != NULL)
		autonomousCommand->Cancel();

	SmartDashboard::PutNumber("driveP", driveP);
	SmartDashboard::PutNumber("driveI", driveI);
	SmartDashboard::PutNumber("driveD", driveD);
	SmartDashboard::PutNumber("driveF", driveF);
	SmartDashboard::PutNumber("drivePIDDistance", drivePIDDistance);

	SmartDashboard::PutNumber("elevatorP", elevatorP);
	SmartDashboard::PutNumber("elevatorI", elevatorI);
	SmartDashboard::PutNumber("elevatorD", elevatorD);
	SmartDashboard::PutNumber("elevatorF", elevatorF);
	SmartDashboard::PutNumber("elevatorPIDDistance", elevatorPIDDistance);

	RobotMap::armFlapSolenoid->Set(DoubleSolenoid::kOff);
	RobotMap::shifterSolenoid->Set(DoubleSolenoid::kOff);
	RobotMap::totePusherSolenoid->Set(DoubleSolenoid::kOff);
	// It seems that we need a Set to confirm the control mode or else it reverts


}

void Robot::TeleopPeriodic() {
	Scheduler::GetInstance()->Run();
	UpdateDashboardPeriodic();
}

void Robot::TestPeriodic() {
	lw->Run();
}
void Robot::UpdateDashboardPeriodic() {

	// Do this every 1/10th of a second, not more often for efficiency
	if (Ticks++%5==0) {
//		Compressor* wC = RobotMap::workingCompressor;
//		if (NULL!=wC) {
//			SmartDashboard::PutBoolean("CompEnabled", wC->Enabled());
//			SmartDashboard::PutBoolean("CompSwitch", wC->GetPressureSwitchValue());
//			SmartDashboard::PutNumber("CompCurrent", wC->GetCompressorCurrent());
//		}

		SmartDashboard::PutNumber("CAN Front Left Fault", RobotMap::driveFrontLeft->GetFaults());
		SmartDashboard::PutNumber("Left Encoder Position", Robot::driveSubsystem->GetLeftEncoderPosition());
		SmartDashboard::PutNumber("Right Encoder Position", Robot::driveSubsystem->GetRightEncoderPosition());
		SmartDashboard::PutNumber("DrivePID Left  Error",RobotMap::driveBackLeft->GetClosedLoopError());
		SmartDashboard::PutNumber("DrivePID Right Error",RobotMap::driveBackRight->GetClosedLoopError());

		SmartDashboard::PutNumber("Elevator Encoder Position", Robot::elevator->GetEncoderPosition());
		SmartDashboard::PutNumber("Elevator PID Error", RobotMap::elevatorMotor1->GetClosedLoopError());
		SmartDashboard::PutNumber("Elevator Position", Robot::elevator->GetPosition());

		RobotMap::Ct->UpdateDashboard();

#ifdef sensors
		if (NULL!=RobotMap::distanceSensor) {
			SmartDashboard::PutNumber("DistanceSensorVoltage", RobotMap::distanceSensor->GetVoltage());  // THIS IS THE LINE THAT IS FAILING!!
		} else {
			printf("distanceSensor pointer NULL\n");
		}
		if (NULL!=RobotMap::colorSensor) {
			SmartDashboard::PutNumber("ColorSensorVoltage", RobotMap::colorSensor->Get());  // THIS IS THE LINE THAT IS FAILING!!
		} else {
			printf("colorSensor pointer NULL\n");
		}
#endif
	}


}

// We have our own parameter file format because the one provided only allows reads params
// from the SmartDashboard at robot init time. We want to change our params when the
// robot is running and immediately save them to disk in case we crash.

// Format is one value per line, not labelled (all pararms are positional).
// Once the value is read the rest of the line is ignored,
// so comments might be possible. But when we overwrite the file.
// But we're not writing back comments right now (could add this later).

// The first line of the file is an integer version number, so we can extend this


int Robot::getInt(FILE *pFile)
{
	char line[120];
	int val;
	fgets(line, sizeof(line), pFile);
	sscanf(line, "%i", &val);
	return val;
}

// stored values are actually floats not doubles (because that's what
// sscanf can parse). I think six or seven digits precision is enough.
double Robot::getDouble(FILE *pFile)
{
	char line[120];
	float val;
	fgets(line, sizeof(line), pFile);
	sscanf(line, "%f", &val);
	return val;
}

void Robot::GetParams() {
	FILE *pFile = fopen("params2015.txt", "r");
	if (NULL != pFile){
		int version = getInt(pFile);
		if (1 == version) {
			// drive PID params
			driveP = getDouble(pFile);
			driveI = getDouble(pFile);
			driveD = getDouble(pFile);
			driveF = getDouble(pFile);

			// elevator PID params
			elevatorP = getDouble(pFile);
			elevatorI = getDouble(pFile);
			elevatorD = getDouble(pFile);
			elevatorF = getDouble(pFile);
		}
		fclose(pFile);
		printf("Loaded params\n  %f %f %f %f\n  %f %f %f %f\n",
			driveP, driveI, driveD, driveF,
			elevatorD, elevatorI, elevatorD, elevatorF);
	}
	else printf("Couldn't read params2015.txt\n");
}

void Robot::SaveParams() {
	// make a backup copy just in case we get interrupted
	system("cp params2105.txt params2015.txt~");
	FILE *pFile = fopen("params2015.txt", "w");
	if (NULL != pFile)
	{
		fprintf(pFile, "%d\n", 1);
		fprintf(pFile, "%f\n", driveP);
		fprintf(pFile, "%f\n", driveI);
		fprintf(pFile, "%f\n", driveD);
		fprintf(pFile, "%f\n", driveF);

		fprintf(pFile, "%f\n", elevatorD);
		fprintf(pFile, "%f\n", elevatorI);
		fprintf(pFile, "%f\n", elevatorD);
		fprintf(pFile, "%f\n", elevatorF);

		fclose(pFile);
		printf("Saved params\n  %f %f %f %f\n  %f %f %f %f\n",
			driveP, driveI, driveD, driveF,
			elevatorD, elevatorI, elevatorD, elevatorF);
	}
	else printf("Couldn't open params2015.txt for write.\n");
}



START_ROBOT_CLASS(Robot);
