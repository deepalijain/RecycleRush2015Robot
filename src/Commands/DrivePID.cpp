// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "DrivePID.h"
#include "../Robot.h"
#include "../Subsystems/Parameters.h"

DrivePID::DrivePID(double leftInches, double rightInches, bool autonomous)  :
	_leftInches(leftInches),
	_rightInches(rightInches),
	_autonomous(autonomous) {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveSubsystem);
	_isFinished = false;
	printf("drivePID constructed for leftInches=%1.2f, rightInches=%1.2f.\n", leftInches, rightInches);
	double wheelDiameter = 6.25; 				// starting guess

	//double ticksPerRotation = 7640;			// empircally determined
	double ticksPerRotation = 6912;			// empircally determined
	double inchesPerRotation = wheelDiameter * 3.14159;
	_leftTicks = leftInches * (ticksPerRotation/inchesPerRotation);
	_rightTicks = rightInches * (ticksPerRotation/inchesPerRotation);
	printf("drivePID constructed for leftTicks=%1.2f, rightInches=%1.2f.\n", _leftTicks, _rightTicks);
}

// Called just before this Command runs the first time
void DrivePID::Initialize() {
	SetTimeout(6000);  // set 8 second timeout. Good enough?
	_timeticks = 0;
	SetInterruptible(false);
	Robot::parameters->UpdateDrivePIDParams();
	// Vestigial:
	// double distance = Parameters::drivePIDDistance;
	printf("drivePID initialized for leftTicks=%1.2f, rightTicks=%1.2f.\n", _leftTicks, _rightTicks);
	Robot::driveSubsystem->SetPIDDistance(_leftTicks, _rightTicks);
}

// Called repeatedly when this Command is scheduled to run
void DrivePID::Execute() {
	_timeticks++;
}

// Make this return true when this Command no longer needs to run execute()
bool DrivePID::IsFinished() {
	double y = Robot::oi->joystick1->GetY();
	double x = Robot::oi->joystick1->GetRawAxis(4);
	if(fabs(y) > 0.15 || fabs(x) > 0.15)
	{
		printf("Drive PID terminated by joystick y=%f, x=%f.\n", y, x);
		return true;
	}
	if (Robot::driveSubsystem->IsFinished()) {
		printf("Drive PID ended at: %d %d / %1.0f %1.0f\n",
				Robot::driveSubsystem->backLeftMotor->GetClosedLoopError(),
				Robot::driveSubsystem->backRightMotor->GetClosedLoopError(),
				Robot::driveSubsystem->GetLeftEncoderPosition(),
				Robot::driveSubsystem->GetRightEncoderPosition());
		printf("Drive PID for %1.0f took %1.2f seconds.\n", Parameters::drivePIDDistance,
															_timeticks/50.0);
		return true;
	}
	return false;
}

// Called once after isFinished returns true
void DrivePID::End() {
	if (!_autonomous) {
		RobotMap::driveBackLeft->SetControlMode(CANSpeedController::kPercentVbus);
		RobotMap::driveBackRight->SetControlMode(CANSpeedController::kPercentVbus);
		Robot::driveCommand->Start();
	}
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void DrivePID::Interrupted() {
	// support back to back drive PID commands
	printf("Drive PID Interrupted\n");
	Initialize();
}
