// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "DriveD2.h"

#include <algorithm>
#include "../Subsystems/Parameters.h"

DriveD2::DriveD2(double distL, double distR) : m_distL(distL) , m_distR(distR) {
	Requires(Robot::driveSubsystem);
	driveSubsystem = Robot::driveSubsystem;
	m_direction = (m_distR > 0.0) ? 1.0 : -1.0;
	if (m_distL != 0) m_ratio = m_distR / m_distL;
	else m_ratio = 0.0;
	printf("DriveD2 constructed for left: %1.2f, right: %1.2f inches, inches per tick %1.6f.\n",
			m_distL, m_distR, RobotMap::inchesPerTick);
}

// Called just before this Command runs the first time
void DriveD2::Initialize() {
	m_encoderInitialL = driveSubsystem->GetLeftEncoderPosition();
	distanceTravelledL = 0.0;
	m_rateLeft = m_initialRate;		// m_rateLeft is always positive

	m_encoderInitialR = driveSubsystem->GetRightEncoderPosition();
	distanceTravelledR = 0.0;
	m_rateRight = m_initialRate;	// m_rateLeft is also always positive

	m_timeTicks = 0;
	m_remainingDistance = 0.0;
	// Disable the voltage ramp rate
	RobotMap::driveBackLeft->SetVoltageRampRate(0.0);
	RobotMap::driveBackRight->SetVoltageRampRate(0.0);
	printf("DriveD2Command initialized: %1.2f, right: %1.2f inches, inches per tick %1.6f.\n",
			m_distL, m_distR, RobotMap::inchesPerTick);
}

// Called repeatedly when this Command is scheduled to run
void DriveD2::Execute() {
	// If we're farther away than five inches then speed up to max
	distanceTravelledL = RobotMap::inchesPerTick * driveSubsystem->GetLeftEncoderPosition() - m_encoderInitialL;
	distanceTravelledR = RobotMap::inchesPerTick * driveSubsystem->GetRightEncoderPosition() - m_encoderInitialR;
	// Left will be the opposite sign of right.
	// When going forward, we expect left to be negative and right to be positive.
	m_remainingDistance =  m_distR - distanceTravelledR;	// might be signed

	// Compute how far we would go if we started decelerating at the max rate
	// It turns out timeToStop = velocity/acceleration and
	// distanceToStop = currentSpeed * timeToStop / 2
	m_timeToStop = m_rateRight/m_rateStep * 0.02;
	double speed = driveSubsystem->GetLeftSpeed();

	m_maxDecelDistance = fabs(speed) * m_timeToStop / 2.0;

	// arbitrarily add 5.0 to our Decel Distance, based on testing
	if (fabs(m_remainingDistance) > (m_maxDecelDistance + 3.5))
	{
		m_rateRight = std::min(m_rateRight + m_rateStep, m_maxRate);
	}
	else
	{
		m_rateRight = std::max(m_rateRight - m_rateStep, 0.0);
	}
	// Now let's check to see how far each side has traveled
	// and scale the right side accordingly
	// The right side goes in the opposite direction, so to get a difference
	// we add.
	double distanceError = distanceTravelledL + distanceTravelledR;

	//voltageRight = voltageLeft + distanceError * voltageScale;
	// For test bot use '-'
	//m_rateRight = m_rateLeft - distanceError * m_rateScale;
	// for driving forward on our robot, left is negative and right is positive, thus the signs below
	driveSubsystem->robotDrive->TankDrive(-m_rateLeft*m_direction, m_rateRight*m_direction, true);

	if (m_timeTicks++%2==0)
	{
		printf("speed=%1.2f (inches per second), timeToStop = %1.4f, maxDecelDistance = %1.4f\n", speed, m_timeToStop, m_maxDecelDistance);
		printf("distanceError = %1.2f, distanceLeft = %1.2f, distanceRight = %1.2f, remainingDistance = %1.2f, rateLeft = %1.2f, rateRight = %1.2f\n",
				distanceError, distanceTravelledL, distanceTravelledR, m_remainingDistance, m_rateLeft, m_rateRight);
	}
}

// Make this return true when this Command no longer needs to run execute()
bool DriveD2::IsFinished() {
	m_isCommandDone = m_remainingDistance < 1.0 || -distanceTravelledL > m_distL;
	return m_isCommandDone;
}

// Called once after isFinished returns true
void DriveD2::End() {
	driveSubsystem->robotDrive->ArcadeDrive(0, 0, true);
	printf("distanceLeft = %f, distanceRight = %f\n",distanceTravelledL, distanceTravelledR);

	// Set the voltage ramp rate for both drive motors
	RobotMap::driveBackLeft->SetVoltageRampRate(Parameters::driveRampRate);
	RobotMap::driveBackRight->SetVoltageRampRate(Parameters::driveRampRate);

	((DriveCommand *)Robot::driveCommand)->Start();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void DriveD2::Interrupted() {

}
