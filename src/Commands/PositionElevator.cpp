// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "PositionElevator.h"

static double elevatorPIDDistance;
int PositionElevator::targetFloor = 0;

PositionElevator::PositionElevator(int n) {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::elevator);
	elevator = Robot::elevator;
	m_n = n;
	printf("PositionElevator constructed for n=%d\n", (int)m_n);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

// Called just before this Command runs the first time
void PositionElevator::Initialize() {
	double curPos;
	SetInterruptible(true);
	Robot::parameters->UpdateElevatorPIDParams();
	// always make sure we're back in position control mode.
	if (!RobotMap::testBot) {
		RobotMap::elevatorMotor1->SetControlMode(CANSpeedController::kPosition);
	}
	curPos = elevator->GetPosition();

	if (m_n == 0) {
		elevatorPIDDistance = curPos;	// hold mode
	}
	else {
		// if we consider tote positions like floors, then we compute which
		// floor the elevator might be just above. In case we're at an exact
		// floor, the -3.0 ticks biases us up. (So if we're within 3 ticks of
		// floor 1, we act like we're at floor 1, not floor 0).
		int curFloor = ((curPos-3.0*m_n)/Robot::elevator->ticksPerTote);
		targetFloor = curFloor += m_n;

		printf("PositionElevator %d, at %d, moving to %d\n", (int)m_n, curFloor, targetFloor);

		// this is just a debugging hack for now
		elevatorPIDDistance = SmartDashboard::GetNumber("elevatorPIDDistance");
		if (elevatorPIDDistance==0.0) {
			elevatorPIDDistance = (targetFloor*elevator->ticksPerTote);
		}
	}
	printf("PositionElevator current position=%1.0f, target position=%1.0f.\n",
			curPos, elevatorPIDDistance);
	if(!RobotMap::testBot)Robot::elevator->SetHeight(elevatorPIDDistance);
}

// Called repeatedly when this Command is scheduled to run
void PositionElevator::Execute() {
	if (RobotMap::testBot) {
		// calculate how much we should move per clock cycle (every 1/50 second)
		// to move a tote's distance in two seconds
		// only continue moving if we're more than two cycles away from our goal
		if (fabs(elevator->GetPosition() - elevatorPIDDistance) > 2*elevator->ticksPerCycle) {
			elevator->Move(elevator->ticksPerCycle*m_n);
		}
	}
}

// Make this return true when this Command no longer needs to run execute()
bool PositionElevator::IsFinished() {
	float up = Robot::oi->joystick1->GetRawAxis(3);
	float down = Robot::oi->joystick1->GetRawAxis(2);
	if (fabs(up) > 0.1 || fabs(down) > 0.1)
	{
		printf("Elevator PID terminated by joystick input y=%f, x=%f.\n", up, down);
		return true;
	}
	if (RobotMap::testBot) return (fabs(elevator->GetPosition() - elevatorPIDDistance) > 2*elevator->ticksPerCycle);
	return false;
}

// Called once after isFinished returns true
void PositionElevator::End() {
	if (!RobotMap::testBot)RobotMap::elevatorMotor1->SetControlMode(CANSpeedController::kPercentVbus);
	Robot::driveElevatorCommand->Start();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void PositionElevator::Interrupted() {
	// change our target!
	targetFloor += m_n;
	elevatorPIDDistance = (targetFloor*Robot::elevator->ticksPerTote);
	printf("PositionElevator updated %d, moving to %d\n", (int)m_n, targetFloor);
	printf("PositionElevator updated current position=%1.0f, target position=%1.0f.\n",
			Robot::elevator->GetPosition(), elevatorPIDDistance);
}
