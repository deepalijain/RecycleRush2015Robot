// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "PositionElevator.h"

// These parameters should be adjustable at runtime
double PositionElevator::wheelDiameter = 2.0; // starting guess
double PositionElevator::elevatorSpeed = 0.25;

// these aren't
double PositionElevator::ticksPerRotation = 1024.0;
double PositionElevator::inchesPerTote = 12.1;
double PositionElevator::inchesPerRotation = wheelDiameter * 3.14159;
double PositionElevator::ticksPerInch = ticksPerRotation / inchesPerRotation;
double PositionElevator::ticksPerTote = ticksPerInch * inchesPerTote;
int PositionElevator::targetFloor = 0;

double PositionElevator::m_curPos = 0.0;

static double elevatorPIDDistance;

PositionElevator::PositionElevator(int n) {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::elevator);
	m_n = n;
	MoveElevatorUpdateParams();
	printf("PositionElevator constructed for n=%d\n", (int)m_n);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

 void  PositionElevator::MoveElevatorUpdateParams() {
	inchesPerRotation = wheelDiameter * 3.14159;
	ticksPerInch = ticksPerRotation / inchesPerRotation;
	ticksPerTote = ticksPerInch * inchesPerTote;
}

// Called just before this Command runs the first time
void PositionElevator::Initialize() {
	// always make sure we're back in position control mode.
	RobotMap::elevatorMotor1->SetControlMode(CANSpeedController::kPosition);
	m_curPos = Robot::elevator->GetPosition();

	if (m_n == 0) {
		elevatorPIDDistance = m_curPos;	// hold mode
	}
	else {
		// if we consider tote positions like floors, then we compute which
		// floor the elevator might be just above. In case we're at an exact
		// floor, the +0.5 below biases us up. (So if we're within 5 ticks of
		// floor 1, we act like we're at floor 1, not floor 0).
		int curFloor = ((m_curPos+5.0*m_n)/ticksPerTote);
		targetFloor = curFloor += m_n;

		printf("PositionElevator %d, at %d, moving to %d\n", (int)m_n, curFloor, targetFloor);

		elevatorPIDDistance = SmartDashboard::GetNumber("elevatorPIDDistance");
		if (elevatorPIDDistance==0.0) {
			elevatorPIDDistance = (targetFloor*ticksPerTote);
		}
	}
	printf("PositionElevator current position=%1.0f, target position=%1.0f.\n",
			m_curPos, elevatorPIDDistance);
	Robot::elevator->SetHeight(elevatorPIDDistance);
}

// Called repeatedly when this Command is scheduled to run
void PositionElevator::Execute() {
	// Nothing here. The Talon's PID loop is doing all the work!
}

// Make this return true when this Command no longer needs to run execute()
bool PositionElevator::IsFinished() {
	float up = Robot::oi->joystick1->GetRawAxis(3);
	float down = Robot::oi->joystick1->GetRawAxis(2);
	if (fabs(up) > 0.1 || fabs(down) > 0.1)
	{
		printf("Elevator PID terminated by joystick input y=%f, x=%f.\n", up, down);
		return true;
	}
	return false;
}

// Called once after isFinished returns true
void PositionElevator::End() {
	RobotMap::elevatorMotor1->SetControlMode(CANSpeedController::kPercentVbus);
	Robot::driveElevatorCommand->Start();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void PositionElevator::Interrupted() {
	// change our target!
	targetFloor += m_n;
	elevatorPIDDistance = (targetFloor*ticksPerTote);
	printf("PositionElevator updated %d, moving to %d\n", (int)m_n, targetFloor);
	printf("PositionElevator updated current position=%1.0f, target position=%1.0f.\n",
			m_curPos, elevatorPIDDistance);
}
