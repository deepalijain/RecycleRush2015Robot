// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "PositionElevator.h"

static double elevatorPIDDistance;
int PositionElevator::targetIndex = 0;

PositionElevator::PositionElevator(int commandDirection, bool trashcan) {
	Requires(Robot::elevator);
	elevator = Robot::elevator;
	this->commandDirection = commandDirection;	// +1 for up, -1 for down, 0 to hold
	this->trashcan = trashcan;			// true if we're move trash cans, false for totes
	printf("PositionElevator constructed for commandDirection=%d, %s version\n",
			commandDirection, trashcan ? "Trash Can" : "Tote");
}

// Called just before this Command runs the first time
void PositionElevator::Initialize() {
	double curPos;
	SetInterruptible(true);
	Robot::parameters->UpdateElevatorPIDParams();
	// always make sure we're back in position control mode.
	if (!RobotMap::testBot) {
		RobotMap::elevatorMotor1->SetControlMode(CANSpeedController::kPosition);
	}
	curPos = elevator->GetPosition();

	if (commandDirection == 0) {
		elevatorPIDDistance = curPos;	// hold mode
	}
	else {
		if (!trashcan) {
			elevator->MoveByTote(commandDirection);
		}
		else {
			elevator->MoveCan(commandDirection);
		}
	}
}

// Called repeatedly when this Command is scheduled to run
void PositionElevator::Execute() {
	if (RobotMap::testBot) {
		// calculate how much we should move per clock cycle (every 1/50 second)
		// to move a tote's distance in two seconds
		// only continue moving if we're more than two cycles away from our goal
		if (fabs(elevator->GetPosition() - elevatorPIDDistance) > 2*elevator->ticksPerCycle) {
			elevator->Move(elevator->ticksPerCycle*commandDirection);
		}
	}
}

// Make this return true when this Command no longer needs to run execute()
bool PositionElevator::IsFinished() {
	// End PID control if the joystick throttles are pressed
	float up = Robot::oi->joystick1->GetRawAxis(3);
	float down = Robot::oi->joystick1->GetRawAxis(2);
	if (fabs(up) > 0.1 || fabs(down) > 0.1)
	{
		printf("Elevator PID terminated by joystick input y=%f, x=%f.\n", up, down);
		return true;
	}
	// Test bot is different. Simulated elevator ends when it reaches set point
	if (RobotMap::testBot) return (fabs(elevator->GetPosition() - elevatorPIDDistance) > 2*elevator->ticksPerCycle);

	// Otherwise, the PID directional move commands end immediately -- the PID loop
	// will do the rest. Except the default command -- holdElevator, that maintains
	// position.
	if (commandDirection!=0) return true;
	return false;
}

// Called once after isFinished returns true
void PositionElevator::End() {
	if (!RobotMap::testBot)RobotMap::elevatorMotor1->SetControlMode(CANSpeedController::kPercentVbus);
	Robot::driveElevatorCommand->Start();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void PositionElevator::Interrupted() {
}
