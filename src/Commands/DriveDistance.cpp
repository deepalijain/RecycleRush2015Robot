// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "DriveDistance.h"

#include <algorithm>
#include "../Subsystems/Parameters.h"

DriveDistance::DriveDistance(double distL, double distR) : _distL(distL) , _distR(distR) {
	Requires(Robot::driveSubsystem);
	wheelDiam = !RobotMap::testBot ? 6.25 : 4.0;
	distancePerRev = 3.14159*wheelDiam;
	inchesPerTick = distancePerRev/(!RobotMap::testBot ? 7680 : 1000);
	printf("DriveDistanceCommand constructed for left: %1.2f, right: %1.2f inches, inches per tick %1.6f.\n",
			_distL, _distR, inchesPerTick);
}

// Called just before this Command runs the first time
void DriveDistance::Initialize() {
	// reset the encoders to 0
	RobotMap::driveBackLeft->SetPosition(0);
	distanceTravelledL = 0.0;
	rateLeft = initialRate;
	RobotMap::driveBackRight->SetPosition(0);
	distanceTravelledR = 0.0;
	rateRight =initialRate;
	ticks = 0;
	remainingDistance = 0.0;
	// Disable the voltage ramp rate
	RobotMap::driveBackLeft->SetVoltageRampRate(0.0);
	RobotMap::driveBackRight->SetVoltageRampRate(0.0);
	printf("DriveDistanceCommand initialized: %1.2f, right: %1.2f inches, inches per tick %1.6f.\n",
			_distL, _distR, inchesPerTick);
}

// Called repeatedly when this Command is scheduled to run
void DriveDistance::Execute() {
	// If we're farther away than five inches then speed up to max
	distanceTravelledL = inchesPerTick * RobotMap::driveBackLeft->GetPosition();
	distanceTravelledR = inchesPerTick * RobotMap::driveBackRight->GetPosition();
	remainingDistance = std::max(_distL - distanceTravelledL, 0.0);
	if (remainingDistance > 5.0)
	{
		rateLeft = std::min(rateLeft + rateStep, maxRate);
	}
	else
	{
		rateLeft = std::max(rateLeft - rateStep, 0.0);
	}
	// Now let's check to see how far each side has traveled
	// and scale the right side accordingly
	// The right side goes in the opposite direction, so to get a difference
	// we add.
	double distanceError = distanceTravelledL + distanceTravelledR;

	//voltageRight = voltageLeft + distanceError * voltageScale;
	// For test bot use '-'
	rateRight = rateLeft - distanceError * rateScale;

	Robot::driveSubsystem->robotDrive->TankDrive(rateLeft, rateRight, true);


	if (ticks++%2==0)
	{
		printf("distanceError = %1.2f, distanceLeft = %1.2f, distanceRight = %1.2f, remainingDistance = %1.2f, rateLeft = %1.2f, rateRight = %1.2f\n",
				distanceError, distanceTravelledL, distanceTravelledR, remainingDistance, rateLeft, rateRight);
	}
}

// Make this return true when this Command no longer needs to run execute()
bool DriveDistance::IsFinished() {
	isCommandDone = remainingDistance < 1.0 || distanceTravelledL > _distL;
	return isCommandDone;
}

// Called once after isFinished returns true
void DriveDistance::End() {
	Robot::driveSubsystem->robotDrive->ArcadeDrive(0, 0, true);
	printf("distanceLeft = %f, distanceRight = %f\n",distanceTravelledL, distanceTravelledR);

	// Set the voltage ramp rate for both drive motors
	RobotMap::driveBackLeft->SetVoltageRampRate(Parameters::driveRampRate);
	RobotMap::driveBackRight->SetVoltageRampRate(Parameters::driveRampRate);

	((DriveCommand *)Robot::driveCommand)->Start();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void DriveDistance::Interrupted() {

}
