// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include <algorithm>
#include "DriveDistanceCommand.h"
#include "../Subsystems/Parameters.h"

DriveDistanceCommand::DriveDistanceCommand(float distL, float distR) {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	distanceL = distL;
	distanceR = distR;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveSubsystem);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

// Called just before this Command runs the first time
void DriveDistanceCommand::Initialize() {
	// reset the encoders to 0
	RobotMap::driveBackLeft->SetPosition(0);
	distanceTravelledL = 0.0;
	voltageLeft = 0.0;
	RobotMap::driveBackRight->SetPosition(0);
	distanceTravelledR = 0.0;
	voltageRight = 0.0;
	ticks = 0;
	// Disable the voltage ramp rate
	RobotMap::driveBackLeft->SetVoltageRampRate(0.0);
	RobotMap::driveBackRight->SetVoltageRampRate(0.0);
}

// Called repeatedly when this Command is scheduled to run
void DriveDistanceCommand::Execute() {
	// If we're farther away than 1 foot then speed up to max
	distanceTravelledL = inchesPerTick * RobotMap::driveBackLeft->GetEncPosition();
	distanceTravelledR = inchesPerTick * RobotMap::driveBackRight->GetEncPosition();
	if (distanceL - distanceTravelledL > 5)
	{
		voltageLeft = std::min(voltageLeft + voltageStep, maxVoltage);
	}
	else
		// We're getting close so slow down
	{
		voltageLeft = std::max(voltageLeft - voltageStep, 0.0F);
	}
	// Now let's check to see how far each side has traveled
	// and scale the right side accordingly
	// The right side goes in the opposite direction, so to get a difference
	// we add.
	distanceError = distanceTravelledL + distanceTravelledR;

	//voltageRight = voltageLeft + distanceError * voltageScale;
	// For test bot use '-'
	voltageRight = voltageLeft - distanceError * voltageScale;

	Robot::driveSubsystem->robotDrive->TankDrive(voltageLeft,voltageRight,true);

	if (ticks++%5==0)
	{
//		printf("distanceError = %f\n", distanceError);
		printf("distanceError = %f, distanceLeft = %f, distanceRight = %f, voltageL = %f, voltageR = %f\n",
				distanceError,distanceTravelledL, distanceTravelledR, voltageLeft, voltageRight);
	}
}

// Make this return true when this Command no longer needs to run execute()
bool DriveDistanceCommand::IsFinished() {
	// Command will be finished when we get to within
	// 1 inch of commanded position
//	remainingDistance = std::max(fabs(distanceTravelledL - distanceL),
//			fabs(distanceTravelledR - distanceR));

	remainingDistance = distanceL - distanceTravelledL;
	isCommandDone = remainingDistance < 5.0;
	return isCommandDone;
}

// Called once after isFinished returns true
void DriveDistanceCommand::End() {
	Robot::driveSubsystem->robotDrive->ArcadeDrive(0, 0, true);
	printf("distanceLeft = %f, distanceRight = %f\n",distanceTravelledL, distanceTravelledR);

	// Set the voltage ramp rate for both drive motors
	RobotMap::driveBackLeft->SetVoltageRampRate(Parameters::driveRampRate);
	RobotMap::driveBackRight->SetVoltageRampRate(Parameters::driveRampRate);

((DriveCommand *)Robot::driveCommand)->Start();

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void DriveDistanceCommand::Interrupted() {

}
