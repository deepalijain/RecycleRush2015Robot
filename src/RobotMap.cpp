// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
CANTalon* RobotMap::driveFrontLeft = NULL;
CANTalon* RobotMap::driveFrontRight = NULL;
RobotDrive* RobotMap::driveSubsystem = NULL;
CANTalon* RobotMap::driveBackLeft = NULL;
CANTalon* RobotMap::driveBackRight = NULL;
CANTalon* RobotMap::elevatorMotor1 = NULL;
CanTalonSRX* RobotMap::elevatorMotor2 = NULL;
CANTalons* RobotMap::Ct = NULL;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

DoubleSolenoid* RobotMap::armFlapSolenoid = NULL;
DoubleSolenoid* RobotMap::shifterSolenoid = NULL;
DoubleSolenoid* RobotMap::totePusherSolenoid = NULL;


void RobotMap::init() {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	Ct = new CANTalons();

	driveFrontLeft = Ct->Init(5, (char *)"FrontLeft");
	
	driveFrontRight = Ct->Init(3, (char *)"FrontRight");

	driveBackLeft = Ct->Init(4, (char *)"BackLeft");
	//driveBackLeft = new TalonSRX(2);

	driveBackRight = Ct->Init(2, (char *)"BackRight");
	//driveBackRight = new TalonSRX(4);
	
	driveSubsystem = new RobotDrive(driveBackLeft, driveBackRight);
	
	driveSubsystem->SetSafetyEnabled(false);
    driveSubsystem->SetExpiration(0.1);
    driveSubsystem->SetSensitivity(0.5);
    driveSubsystem->SetMaxOutput(1.0);
	
	shifterSolenoid = new DoubleSolenoid(5, 4, 5);

	elevatorMotor1 = Ct->Init(1, (char *)"Elevator Lead");
	elevatorMotor1->SetControlMode(CANSpeedController::kPercentVbus);
	
//	elevatorMotor2 = Ct->Init(1, (char *)"Pickup Follow");
	// Need to use CanTalonSRX for elevatorMotor2 so we can invert the following Talon
	// See Software Reference Manual 21.15
	elevatorMotor2 = new CanTalonSRX(6);

	armFlapSolenoid = new DoubleSolenoid(5, 0, 1);
	totePusherSolenoid = new DoubleSolenoid(5, 2, 3);


    driveBackLeft->SetControlMode(CANSpeedController::kPercentVbus);
    driveBackRight->SetControlMode(CANSpeedController::kPercentVbus);
    elevatorMotor1->SetControlMode(CANSpeedController::kPercentVbus);

    // Set the FRONT talons to follow the BACK talons
    driveFrontLeft->SetControlMode(CANSpeedController::kFollower);
    driveFrontLeft->Set(4);
    driveFrontLeft->EnableControl();
    driveFrontRight->SetControlMode(CANSpeedController::kFollower);
    driveFrontRight->Set(3);
    driveFrontRight->EnableControl();
    elevatorMotor2->SetModeSelect(CanTalonSRX::kMode_SlaveFollower);
    elevatorMotor2->SetDemand(1);
    elevatorMotor2->SetRevMotDuringCloseLoopEn(1);
}
