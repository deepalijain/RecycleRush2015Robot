// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
CANTalon* RobotMap::driveFrontLeft = NULL;
CANTalon* RobotMap::driveFrontRight = NULL;
RobotDrive* RobotMap::driveSubsystem = NULL;
CANTalon* RobotMap::driveBackLeft = NULL;
CANTalon* RobotMap::driveBackRight = NULL;
CANTalon* RobotMap::elevatorMotor1 = NULL;
CanTalonSRX* RobotMap::elevatorMotor2 = NULL;
CANTalons* RobotMap::Ct = NULL;
bool RobotMap::testBot = false;

double RobotMap::ticksPerRotation = 0.0;
double RobotMap::wheelDiameter = 0.0;
double RobotMap::inchesPerRotation = 0.0;
double RobotMap::ticksPerInch = 0.0;
double RobotMap::inchesPerTick = 0.0;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

DoubleSolenoid *RobotMap::armFlapSolenoid = NULL;
DoubleSolenoid *RobotMap::shifterSolenoid = NULL;
DoubleSolenoid *RobotMap::totePusherSolenoid = NULL;

void RobotMap::init() {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	Ct = new CANTalons();

	// Try set setup the elevator. This isn't present on the testBot,
	// so we can use its absence to indicate that we're running on the
	// testBot, and adjust some things accordingly
	elevatorMotor1 = Ct->Init(1, (char *)"Elevator Lead");
	testBot = !Ct->Status(1);

	ticksPerRotation = (!testBot ? 7680 : 1000);
	wheelDiameter = (!testBot ? 6.25 : 4.3);
	inchesPerRotation = wheelDiameter * 3.14159;
	ticksPerInch = ticksPerRotation/inchesPerRotation;
	inchesPerTick = 1.0/ticksPerInch;

	driveFrontLeft = Ct->Init(5, (char *)"FrontLeft");
	
	driveFrontRight = Ct->Init(3, (char *)"FrontRight");

	driveBackLeft = Ct->Init(4, (char *)"BackLeft");

	driveBackRight = Ct->Init(2, (char *)"BackRight");
	
	driveSubsystem = new RobotDrive(driveBackLeft, driveBackRight);
	
	driveSubsystem->SetSafetyEnabled(false);
    driveSubsystem->SetExpiration(0.1);
    driveSubsystem->SetSensitivity(0.5);
    driveSubsystem->SetMaxOutput(1.0);
	
	shifterSolenoid = new DoubleSolenoid(7, 4, 5);

	//	elevatorMotor2 = Ct->Init(1, (char *)"Pickup Follow");
	// Need to use CanTalonSRX for elevatorMotor2 so we can invert the following Talon
	// See Software Reference Manual 21.15
	elevatorMotor2 = new CanTalonSRX(6);

	armFlapSolenoid = new DoubleSolenoid(7, 0, 1);
	totePusherSolenoid = new DoubleSolenoid(7, 2, 3);

    driveBackLeft->SetControlMode(CANSpeedController::kPercentVbus);
    driveBackRight->SetControlMode(CANSpeedController::kPercentVbus);

    // Set the FRONT talons to follow the BACK talons
    driveFrontLeft->SetControlMode(CANSpeedController::kFollower);
    // Don't mess with ramp rate and PID control at the same time
    // driveFrontLeft->SetVoltageRampRate(20.0);
    driveFrontLeft->Set(4);
    driveFrontLeft->EnableControl();
    driveFrontRight->SetControlMode(CANSpeedController::kFollower);
    // Don't mess with ramp rate and PID control at the same time
    // driveFrontRight->SetVoltageRampRate(20.0);
    driveFrontRight->Set(2);
    driveFrontRight->EnableControl();

    //Set the sensor directions to normal
    driveBackRight->SetSensorDirection(false);
    driveBackLeft->SetSensorDirection(false);

    //elevatorMotor1->SetControlMode(CANSpeedController::kPercentVbus);

    //Configure one elevator motor a follower and the other one a closed loop master
    elevatorMotor2->SetModeSelect(CanTalonSRX::kMode_SlaveFollower);
    // SetDemand is how you set the leader in CanTalonSRX
    elevatorMotor2->SetDemand(1);
    elevatorMotor2->SetRevMotDuringCloseLoopEn(1);

}
