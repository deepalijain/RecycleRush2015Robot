// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
CANTalon* RobotMap::driveFrontLeft = NULL;
CANTalon* RobotMap::driveFrontRight = NULL;
RobotDrive* RobotMap::driveSubsystem = NULL;
CANTalon* RobotMap::driveBackLeft = NULL;
CANTalon* RobotMap::driveBackRight = NULL;
Encoder* RobotMap::driveLeftEncoder = NULL;
Encoder* RobotMap::driveRightEncoder = NULL;
CANTalon* RobotMap::pickupMotor1 = NULL;
CanTalonSRX* RobotMap::pickupMotor2 = NULL;
Encoder* RobotMap::pickupSubsystempickupEncoder = NULL;
CANTalons* RobotMap::Ct = NULL;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

DoubleSolenoid* RobotMap::armFlapSolenoid = NULL;
DoubleSolenoid* RobotMap::shifterSolenoid = NULL;
DoubleSolenoid* RobotMap::totePusherSolenoid = NULL;


void RobotMap::init() {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	LiveWindow* lw = LiveWindow::GetInstance();
	Ct = new CANTalons();

	driveFrontLeft = Ct->Init(5, (char *)"FrontLeft");
	lw->AddActuator("DriveSubsystem", "frontLeftMotor", (TalonSRX*) driveFrontLeft);
	
	driveFrontRight = Ct->Init(2, (char *)"FrontRight");
	lw->AddActuator("DriveSubsystem", "frontRightMotor", (TalonSRX*) driveFrontRight);

	driveBackLeft = Ct->Init(4, (char *)"BackLeft");
	//driveBackLeft = new TalonSRX(2);
	lw->AddActuator("DriveSubsystem", "backLeftMotor", (TalonSRX*) driveBackLeft);

	driveBackRight = Ct->Init(3, (char *)"BackRight");
	//driveBackRight = new TalonSRX(4);
	lw->AddActuator("DriveSubsystem", "backRightMotor", (TalonSRX*) driveBackRight);
	
	driveSubsystem = new RobotDrive(driveBackLeft, driveBackRight);
	
	driveSubsystem->SetSafetyEnabled(false);
        driveSubsystem->SetExpiration(0.1);
        driveSubsystem->SetSensitivity(0.5);
        driveSubsystem->SetMaxOutput(1.0);
        driveFrontLeft->SetVoltageRampRate(0.1);
        driveFrontRight->SetVoltageRampRate(0.1);
        driveBackLeft->SetVoltageRampRate(0.1);
        driveBackRight->SetVoltageRampRate(0.1);
//        pickupMotor1->SetVoltageRampRate(0.02);

	
	driveLeftEncoder = new Encoder(0, 1, false, Encoder::k4X);
	lw->AddSensor("DriveSubsystem", "lEncoder", driveLeftEncoder);
	driveLeftEncoder->SetDistancePerPulse(1.0);
        driveLeftEncoder->SetPIDSourceParameter(Encoder::kRate);
	driveRightEncoder = new Encoder(2, 3, false, Encoder::k4X);
	lw->AddSensor("DriveSubsystem", "rEncoder", driveRightEncoder);
	driveRightEncoder->SetDistancePerPulse(1.0);
        driveRightEncoder->SetPIDSourceParameter(Encoder::kRate);

        shifterSolenoid = new DoubleSolenoid(5, 4, 5);

	pickupMotor1 = Ct->Init(1, (char *)"Pickup Lead");
	lw->AddActuator("PickupSubsystem", "pickupMotor1", (Talon*) pickupMotor1);
	pickupMotor1->SetControlMode(CANSpeedController::kPercentVbus);
	
//	pickupMotor2 = Ct->Init(1, (char *)"Pickup Follow");
	// Need to use CanTalonSRX for pickupMotor2 so we can invert the following Talon
	// See Software Reference Manual 21.15
	pickupMotor2 = new CanTalonSRX(6);
	lw->AddActuator("PickupSubsystem", "pickupMotor2", (Talon*) pickupMotor2);
	
	pickupSubsystempickupEncoder = new Encoder(4, 5, false, Encoder::k4X);
	lw->AddSensor("PickupSubsystem", "pickupEncoder", pickupSubsystempickupEncoder);
	pickupSubsystempickupEncoder->SetDistancePerPulse(1.0);
        pickupSubsystempickupEncoder->SetPIDSourceParameter(Encoder::kRate);

        armFlapSolenoid = new DoubleSolenoid(5, 0, 1);

        totePusherSolenoid = new DoubleSolenoid(5, 2, 3);


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
//	Ct = new CANTalons();
//
//	driveFrontLeft = Ct->Init(5, (char *)"FrontLeft");
//	//lw->AddActuator("DriveSubsystem", "motorControllerFrontLeft", (CANTalon*) driveFrontLeft);
//	driveFrontRight =  Ct->Init(3, (char *)"FrontRight");
//	//lw->AddActuator("DriveSubsystem", "motorControlleFrontRight", (CANTalon*) driveSubsystemmotorControlleFrontRight);
//	driveBackLeft  =  Ct->Init(4, (char *)"BackLeft");
//	//lw->AddActuator("DriveSubsystem", "motorControllerBackLeft", (CANTalon*) driveSubsystemmotorControllerBackLeft);
//	driveBackRight =  Ct->Init(2, (char *)"BackRight");
//	//lw->AddActuator("DriveSubsystem", "motorControllerBackRight", (CANTalon*) driveSubsystemmotorControllerBackRight);


    driveBackLeft->SetControlMode(CANSpeedController::kPercentVbus);
    driveBackRight->SetControlMode(CANSpeedController::kPercentVbus);
    pickupMotor1->SetControlMode(CANSpeedController::kPercentVbus);
    // Set the back talons to follow the front talons
    driveFrontLeft->SetControlMode(CANSpeedController::kFollower);
    driveFrontLeft->Set(4);
    driveFrontLeft->EnableControl();
    driveFrontRight->SetControlMode(CANSpeedController::kFollower);
    driveFrontRight->Set(3);
    driveFrontRight->EnableControl();
    pickupMotor2->SetModeSelect(CanTalonSRX::kMode_SlaveFollower);
    pickupMotor2->SetDemand(1);
    pickupMotor2->SetRevMotDuringCloseLoopEn(1);
}
